-module(border_control_transform).

-export([parse_transform/2, format_error/1]).

%%=============================================================================
%% Public API
%%=============================================================================
parse_transform(Forms, Options) ->
	lists:foldl(fun(Form, Acc) ->
	                maybe_do_transform(Options, Form, Acc)
	            end,
	            #{default => get_records(Forms)},
	            Forms),
	Forms.

maybe_do_transform(Options, {attribute, _, border_control, RecordSpec}, FormDict) ->
	do_transform(Options, RecordSpec, FormDict);
maybe_do_transform(_, _, FormDict) ->
	FormDict.

do_transform(Options, {Module, all}, FormDict1) ->
	FormDict2 = maybe_update_formdict(Module, FormDict1),
	ModuleDict = maps:get(Module, FormDict2, #{}),
	do_transform(Options, {Module, maps:keys(ModuleDict)}, FormDict2);
do_transform(Options, {Module, Records}, FormDict) when is_list(Records) ->
	lists:foldl(fun(Record, FormDict0) ->
	                do_transform(Options, {Module, Record}, FormDict0)
	            end,
	            FormDict,
	            Records);
do_transform(Options, {Module, Record}, FormDict1) when is_atom(Record) ->
	FormDict2 = maybe_update_formdict(Module, FormDict1),
	generate_beam(Options, maybe_generate_file(Module, Record, FormDict2)),
	FormDict2;
do_transform(Options, Record, FormDict) ->
	do_transform(Options, {default, Record}, FormDict).

maybe_generate_file(Module, Record, FormDict) ->
	case maps:is_key(Record, maps:get(Module, FormDict)) of
		true ->
			generate_file(Module, Record, maps:get(Record, maps:get(Module, FormDict)));
		false ->
			io:format("Record definition (~p) was not found\n", [Record]),
			erlang:error(undefined)
	end.	

generate_file(Module, Record, {RecordInfoRaw, RecordInfoParsed}) ->
	Terms = generate(Module, Record, RecordInfoRaw, RecordInfoParsed),
	Text  = erl_prettypr:format(erl_syntax:form_list(Terms)),
	
	File = ["%% -*- coding: utf-8 -*-\n",
	        "%% Automatically generated, do not edit\n",
	        "%% Generated by bcast_model_transform\n",
	        Text],

	Sourcefile = filename:join(lists:reverse([lists:concat([Record, ".erl"]), "src", "."])),
	ok = file:write_file(Sourcefile, File),
	Sourcefile.

generate_beam(CompileOptions, Sourcefile) ->
	Outdir   = lists:keyfind(outdir, 1, CompileOptions),
	Options1 = proplists:get_value(options, ?MODULE:module_info(compile)),
	Options2 = lists:keystore(source, 1, Options1, {source, Sourcefile}),
	Options3 = lists:keystore(outdir, 1, Options2, Outdir),
	c:c(Sourcefile, Options3).

format_error({_Cat, Error}) ->
	Error.

%%=============================================================================
%% Private methods
%%=============================================================================
%% Accessors
%%=====================================
get_attributes(Type, Forms) ->
	get_attributes(Type, Forms, []).

get_attributes(_, [], Acc) ->
	lists:reverse(Acc);
get_attributes(Type, [Form|Forms], Acc) when size(Form) < 3 ->
	get_attributes(Type, Forms, Acc);
get_attributes(Type, [Form|Forms], Acc) when element(1, Form) =:= attribute andalso
                                             element(3, Form) =:= Type ->
	get_attributes(Type, Forms, [Form|Acc]);
get_attributes(Type, [_|Forms], Acc) ->
	get_attributes(Type, Forms, Acc).	

get_records(Forms) ->
	lists:foldl(fun({_,_,_,RecordInfo0} = RecordInfo, Acc) ->
					{Record, RecordInfo1} = parse_rec_spec(RecordInfo0),
	                Acc#{Record => {RecordInfo, RecordInfo1}}
	            end,
	            #{},
	            get_attributes(record, Forms)).

forms_from_file(Module, Filename) ->
	{ok, File}      = file:read_file(Filename),
	{ok, Tokens, _} = erl_scan:string(binary_to_list(File)),
	expand_includes(Module, abstact(Tokens), []).

paths(Module) ->
	Options = proplists:get_value(options, Module:module_info(compile)),
	[X || {i, X} <- Options].

filename(Module) ->
	Info = Module:module_info(compile),
	{source, Filename} = lists:keyfind(source, 1, Info),
	Filename.

findfile(Module, Filename1) ->
	{ok, File, Filename2} = file:path_open(paths(Module), Filename1, [read]),
	file:close(File),
	Filename2.

abstact(Tokens) ->
	abstact(Tokens, [], []).

abstact([], _, Forms) ->
	[tokens_to_abstact(X) || X <- lists:reverse(Forms)];
abstact([{dot, _} = Token | Tokens], Form, Forms) ->
	abstact(Tokens, [], [lists:reverse([Token | Form]) | Forms]);
abstact([Token | Tokens], Form, Forms) ->
	abstact(Tokens, [Token | Form], Forms).

tokens_to_abstact(Tokens) ->
	tokens_to_abstact([fun erl_parse:parse_form/1, fun erl_parse:parse_exprs/1, fun erl_parse:parse_term/1], Tokens).

tokens_to_abstact([], _) -> {error, invalid_tokens};
tokens_to_abstact([Fun | Funs], Tokens) ->
	case Fun(Tokens) of
		{ok, Abs} -> Abs;
		_ -> tokens_to_abstact(Funs, Tokens)
	end.

expand_includes(_, [], Expanded) -> Expanded;
expand_includes(Module, [{attribute, _, include, Filename}|Forms], Expanded) ->
	expand_includes(Module, Forms, Expanded ++ forms_from_file(Module, findfile(Module, Filename)));
expand_includes(Module, [Form|Forms], Expanded) ->
	expand_includes(Module, Forms, Expanded ++ [Form]).

%%=====================================
%% FormDict Functions
%%=====================================
maybe_update_formdict(Module, FormDict) ->
	case maps:is_key(Module, FormDict) of
		true -> FormDict;
		false -> update_formdict(Module, FormDict)
	end.

update_formdict(Module, FormDict) ->
	FormDict#{Module => get_records(forms_from_file(Module, filename(Module)))}.

%%=====================================
%% Parsers
%%=====================================
parse_rec_spec({Record, FieldInfo}) ->
	{_, Properties} = lists:foldl(fun(FieldSpec, {Index, Acc}) ->
	                                  {Field, Types} = parse_record_field(FieldSpec),
	                                  {Index+1, [{Index, Field, Types}|Acc]}
	                              end,
	                              {2, []},
	                              FieldInfo),
	{Record, lists:reverse(Properties)}.

parse_record_field({record_field,_,{_,_,Field}}) ->
	{Field, undefined};
parse_record_field({record_field,_,{_,_,Field},_}) ->
	{Field, undefined};
parse_record_field({typed_record_field,{record_field,_,{_,_,Field}},Types}) ->
	{Field, parse_type(Types)};
parse_record_field({typed_record_field,{record_field,_,{_,_,Field},_},Types}) ->
	{Field, parse_type(Types)}.

parse_type({Type, _, Value}) ->
	{Type, [Value]};
parse_type({_, _, record, [{atom,_,Record}]}) ->
	{record, {Record, []}};
parse_type({_, _, Type, any}) ->
	{Type, [any]};
parse_type({_, _, Type, Parameters}) ->
	{Type, [parse_type(P) || P <- Parameters]}.

%%=====================================
%% Function Generation
%%=====================================
-define(generate(A,B,C), {fun A/5, B, C}).
generate(Module, Record, RecordInfoRaw, RecordInfoParsed) ->
	Generate = [?generate(generate_get_record_infos0, get_record_infos, 0),
	            ?generate(generate_new0, new, 0),
	            ?generate(generate_new1, new, 1),
	            ?generate(generate_get2, get, 2),
	            ?generate(generate_set3, set, 3),
	            ?generate(generate_from_json1,     from_json,     1),
	            ?generate(generate_from_map1,      from_map,      1),
	            ?generate(generate_from_proplist1, from_proplist, 1),
	            ?generate(generate_from_protobuf1, from_protobuf, 1),
	            ?generate(generate_to_json1,       to_json,       1),
	            ?generate(generate_to_map1,        to_map,        1),
	            ?generate(generate_to_proplist1,   to_proplist,   1),
	            ?generate(generate_to_protobuf1,   to_protobuf,   1)],

	{Exports, Functions} = lists:unzip(do_generate(Module, Record, 4, RecordInfoRaw, RecordInfoParsed, Generate, [])),
	[{attribute, 1, module, Record}, setelement(2, RecordInfoRaw, 2)] ++ lists:reverse(Exports) ++ lists:reverse(Functions).
	

do_generate(_, _, _, _, _, [], Acc) ->
	Acc;
do_generate(Module, Record, Line, RecordInfoRaw, RecordInfoParsed, [Generator| Generate], Acc0) ->
	{Fun, Name, Arity} = Generator,
	Acc1 = [{{attribute, 3, export, [{Name, Arity}]},
			 Fun(Module, Record, Line, RecordInfoRaw, RecordInfoParsed)}|
	 		Acc0],
	do_generate(Module, Record, Line+1, RecordInfoRaw, RecordInfoParsed, Generate, Acc1).

generate_get_record_infos0(_, _, Line, _, RecordInfoParsed) ->
	{function,Line,get_record_infos,0,[
		{clause,Line,[],[],[
			erl_parse:abstract(RecordInfoParsed, [{line, Line}])
		]}
	]}.

generate_new0(_, Record, Line, _, _) ->
	{function,Line,new,0,[
		{clause,Line,[],[],[
			{record,Line,Record,[]}
		]}
	]}.

generate_new1(_, _, Line, _, _) ->
	 Clauses = [
	 	{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_binary},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{atom,Line,from_json},
					[
						{var,Line,'Value'}
					]
				}
			]
		},
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_map},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{atom,Line,from_map},					
					[
						{var,Line,'Value'}
					]
				}
			]
		},
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_list},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{atom,Line,from_proplist},
					[
						{var,Line,'Value'}
					]
				}
			]
		}
	 ],
	 {function, Line, new, 1, Clauses}.

generate_get2(_, Record, Line, _, RecordInfoParsed) ->
	Clauses = lists:map(fun({_,Field,_}) ->
	                        generate_get2_clause(Line, Record, Field)
	                    end,
		                RecordInfoParsed),
	{function, Line, get, 2, Clauses}.
generate_get2_clause(Line, Record, Field) ->
	{
		clause,
		Line,
		[{atom,Line,Field},{var,Line,'Record'}],
		[],
		[
			{record_field,Line,{var,Line,'Record'},Record,{atom, Line, Field}}
		]
	}.

generate_set3(_, Record, Line, _, RecordInfoParsed) ->
	Clauses = lists:foldl(fun({_, Field, Type}, Acc) ->
	                          [generate_set3_clause(Line, Record, Field, Type) | Acc]
	                      end,
	                      [],
	                      RecordInfoParsed),
	{function,Line,set,3,Clauses}.

generate_set3_clause(Line, Record, Field, undefined) ->
	{
		clause,
		Line,
		[
			{atom,Line,Field},
			{var,Line,'Value'},
			{var,Line,'Record'}
		],
		[],
		[
			{
				record,
				Line,
				{var,Line,'Record'},
				Record,
				[
					{record_field,Line,{atom,Line,Field},{var,Line,'Value'}}
				]
			}
		]
	};
generate_set3_clause(Line, Record, Field, Type) ->
	{
		clause,
		Line,
		[
			{atom,Line,Field},
			{var,Line,'Value'},
			{var,Line,'Record'}
		],
		[],
		[
			{
				match,
				Line,
				{atom,Line,ok},
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,validate}
					},
					[
						{var,Line,'Value'},
						erl_parse:abstract(Type, [{line, Line}]),
						{call,Line,{atom,Line,get_record_infos},[]}
					]
				}
			},
			{
				record,
				Line,
				{var,Line,'Record'},
				Record,
				[
					{record_field,Line,{atom,Line,Field},{var,Line,'Value'}}
				]
			}
		]
	}.

generate_from_json1(_, Record, Line, _, _) ->
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_binary},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,from_json}
					},
					[
						erl_parse:abstract({record, {Record, []}}, [{line, Line}]),
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}						
					]
				}
			]
		}
	],
	{function,Line,from_json,1,Clauses}.

generate_from_map1(_, Record, Line, _, _) ->
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_map},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,from_map}
					},
					[
						erl_parse:abstract({record, {Record, []}}, [{line, Line}]),
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}
					]
				}
			]
		}
	],
	{function,Line,from_map,1,Clauses}.

generate_from_proplist1(_, Record, Line, _, _) ->
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_list},
						[
							{var,Line,'Value'}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,from_proplist}
					},
					[
						erl_parse:abstract({record, {Record, []}}, [{line, Line}]),
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}
					]
				}
			]
		}
	],
	{function,Line,from_proplist,1,Clauses}.

generate_from_protobuf1(Module, Record, Line, _, _) ->
	Clauses = [{clause,
	            Line,
	            [{var,Line,'Value'}],
	            [[{call,
	              Line,
	              {atom,Line,is_binary},
	              [{var,Line,'Value'}]}]],
	             [{call,
	              Line,
	              {remote,
	               Line,
	               {atom,Line,Module},
	               {atom,Line,decode_msg}},
	               [{var,Line,'Value'},
	                {atom,Line,Record}]}]}],
	{function,Line,from_protobuf,1,Clauses}.

generate_to_json1(_, Record, Line, _, RecordInfoParsed) ->
	TupleLength = length(RecordInfoParsed) + 1,
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_record},
						[
							{var,Line,'Value'},
							{atom,Line,Record},
							{integer,Line,TupleLength}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,to_json}
					},
					[
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}
					]
				}
			]
		}
	],
	{function,Line,to_json,1,Clauses}.

generate_to_map1(_, Record, Line, _, RecordInfoParsed) ->
	TupleLength = length(RecordInfoParsed) + 1,
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_record},
						[
							{var,Line,'Value'},
							{atom,Line,Record},
							{integer,Line,TupleLength}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,to_map}
					},
					[
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}
					]
				}
			]
		}
	],
	{function,Line,to_map,1,Clauses}.

generate_to_proplist1(_, Record, Line, _, RecordInfoParsed) ->
	TupleLength = length(RecordInfoParsed) + 1,
	Clauses = [
		{
			clause,
			Line,
			[{var,Line,'Value'}],
			[
				[
					{
						call,
						Line,
						{atom,Line,is_record},
						[
							{var,Line,'Value'},
							{atom,Line,Record},
							{integer,Line,TupleLength}
						]
					}
				]
			],
			[
				{
					call,
					Line,
					{
						remote,
						Line,
						{atom,Line,border_control},
						{atom,Line,to_proplist}
					},
					[
						{call,Line,{atom,Line,get_record_infos},[]},
						{var,Line,'Value'}
					]
				}
			]
		}
	],
	{function,Line,to_proplist,1,Clauses}.

generate_to_protobuf1(Module, Record, Line, _, RecordInfoParsed) ->
	TupleLength = length(RecordInfoParsed) + 1,
	Clauses = [{clause,
	            Line,
	            [{var,Line,'Value'}],
	            [[{call,
	               Line,
	               {atom,Line,is_record},
	               [{var,Line,'Value'},
	                {atom,Line,Record},
	                {integer,Line,TupleLength}]}]],
	            [{call,
	              Line,
	              {remote,
	               Line,
	               {atom,Line,Module},
	               {atom,Line,encode_msg}},
	              [{var,Line,'Value'}]}]}],
	{function,Line,to_protobuf,1,Clauses}.

